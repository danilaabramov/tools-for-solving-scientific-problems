disp('//////////////////////////////////////////////////////////////////////////1');
% Создаем матрицу x1
x1 = rand(15);
% Выделяем подматрицу x2 из последних пяти строк и столбцов матрицы x1
x2 = x1(11:15, 11:15);
disp(x1);
disp(x2);

disp('//////////////////////////////////////////////////////////////////////////2');
% Задаем размер матрицы x1
m = 6;
n = 5;
% Создаем матрицу x1, заполненную произвольными числами от 0 до 1
x1 = rand(m, n);
% Создаем матрицу x2, в которой будут храниться четные строки первой матрицы
x2 = x1(2:2:end, :);
% Создаем матрицу x3, в которой будут храниться нечетные столбцы первой матрицы
x3 = x1(:, 1:2:end);
% Выводим все три матрицы на экран
disp('Матрица x1:');
disp(x1);
disp('Матрица x2 (четные строки матрицы x1):');
disp(x2);
disp('Матрица x3 (нечетные столбцы матрицы x1):');
disp(x3);

disp('//////////////////////////////////////////////////////////////////////////3');
% Задаем диапазон значений и количество элементов
x_min = -1;
x_max = 1;
n = 100;
% Создаем вектор-строку x1
x1 = linspace(x_min, x_max, n);
% Зануляем элементы, которые меньше 0.5
x1(x1 < 0.5) = 0;
disp(x1);

disp('//////////////////////////////////////////////////////////////////////////4');
% Задаем размерность матриц
n = 3;
% Создаем матрицы x1 и x2 с произвольными числами
x1 = rand(n);
x2 = rand(n);
% Перемножаем матрицы по правилам матричного умножения
mult_matr = x1 * x2;
% Перемножаем матрицы поэлементно
mult_elem = x1 .* x2;
% Выводим результаты на экран
disp('Матрица-1 x1:');
disp(x1);
disp('Матрица-2 x2:');
disp(x2);
disp('Результат перемножения матриц по правилам матричного умножения:');
disp(mult_matr);
disp('Результат поэлементного перемножения матриц:');
disp(mult_elem);

disp('//////////////////////////////////////////////////////////////////////////5');
% Создание вектор-строки и вектор-столбца
x1 = rand(1, 5); % случайные числа от 0 до 1, размерность 1x5
x2 = rand(5, 1); % случайные числа от 0 до 1, размерность 5x1
% Перемножение по правилам матричного умножения
mat_mult = x1 * x2;
% Перемножение поэлементно
elem_mult = x1 .* x2;
% Вывод результатов
disp("Результат перемножения по правилам матричного умножения:");
disp(mat_mult);
disp("Результат поэлементного перемножения:");
disp(elem_mult);

disp('//////////////////////////////////////////////////////////////////////////6');
% Создаем случайные матрицы
n = 1000;
k = 500;
m = 1000;
x1 = rand(n, k);
x2 = rand(k, m);
% Стандартное перемножение
tic;
x3_std = x1 * x2;
t_std = toc;
% Поэлементное перемножение
tic;
[n, ~] = size(x1);
[k, m] = size(x2);
x3 = zeros(n, m);
for i = 1:n
    for j = 1:m
        for l = 1:k
            x3(i, j) = x3(i, j) + x1(i, l) * x2(l, j);
        end
    end
end
t_elem = toc;
% Выводим время выполнения
fprintf('Время стандартного перемножения: %.4f секунд\n', t_std);
fprintf('Время поэлементного перемножения: %.4f секунд\n', t_elem);

disp('//////////////////////////////////////////////////////////////////////////7');
% Создание вектор-строки x1
x1 = rand(1, 1000);
% Сравнение производительности
t1 = timeit(@() elementwise(x1));
t2 = timeit(@() vectorized(x1));
fprintf("Время поэлементного алгоритма: %f s\n", t1)
fprintf("Время векторизованного алгоритма: %f s\n", t2)

disp('//////////////////////////////////////////////////////////////////////////8');
% создание матрицы x1 размером 5x6
x1 = rand(5, 6);
% вычисление матрицы x2 с разностями строк x1
x2 = diff(x1, 1, 1);
% добавление нулевой строки к x2, чтобы размеры соответствовали размерам x1
x2 = [zeros(1, size(x2, 2)); x2];
% вычисление матрицы x3 с разностями столбцов x1
x3 = diff(x1, 1, 2);
% добавление нулевого столбца к x3, чтобы размеры соответствовали размерам x1
x3 = [zeros(size(x3, 1), 1), x3];

disp('//////////////////////////////////////////////////////////////////////////9');
% создание вектор-строки x1
x1 = rand(1, 10);
% вычисление вектора x2
x2 = (x1(1:end-2) + x1(2:end-1) + x1(3:end)) / 3;
disp(x2)

disp('//////////////////////////////////////////////////////////////////////////10');
% Создание матрицы x1
x1 = rand(5, 7);
% Создание матрицы x2, содержащей элементы x1 < 0.5
x2 = x1;
x2(x1 >= 0.5) = 0;
disp(x2)

disp('//////////////////////////////////////////////////////////////////////////11');
% Создание матрицы x1
x1 = rand(5, 5);
% Создание матрицы x2, заполненной нулями
x2 = zeros(size(x1));
% Заполнение элементов x2, которые меньше x1 < 0.5, единицами
x2(x1 < 0.5) = 1;
disp(x2)

disp('//////////////////////////////////////////////////////////////////////////12');
% задаем размер матрицы и диапазон значений
n = 101;
x_range = linspace(-1, 1, n);
y_range = linspace(-1, 1, n);
% создаем сетку значений
[x, y] = meshgrid(x_range, y_range);
% вычисляем расстояние от центра
dist = sqrt(x.^2 + y.^2);

disp('//////////////////////////////////////////////////////////////////////////13');
x1 = linspace(-1, 1, 1000); % Создание вектора-строки x1
x2 = sin(x1); % Создание вектора-строки x2
x3 = cos(x1); % Создание вектора-строки x3
% Построение графика
subplot(1,3,1);
plot(x1, x2, 'b-', x1, x3, 'r-')
xlabel('x')
ylabel('y')
title('График синуса и косинуса')
legend('sin(x)', 'cos(x)')

disp('//////////////////////////////////////////////////////////////////////////14');
% Поэлементный подход
x1 = linspace(-1, 1, 1000);
x2 = zeros(1, length(x1));
% Поэлементный подход
tic
for i = 1:length(x1)
    x2(i) = sin(x1(i));
end
time1 = toc;
% Векторизованный подход
tic
x2_vect = sin(x1);
time2 = toc;
% Сравнение производительности
fprintf('Поэлементный подход: %f сек.\n', time1);
fprintf('Векторизованный подход: %f сек.\n', time2);

disp('//////////////////////////////////////////////////////////////////////////15');
n = 1000000;
x1 = rand(1,n);
% поэлементный алгоритм
tic;
sum_ = 0;
for i = 1:n
    sum_ = sum_ + x1(i);
end
time1 = toc;
% встроенная функция
tic;
sum_all = sum(x1);
time2 = toc;
% вывод результатов
fprintf('Сумма поэлементно: %f, время: %f сек.\n', sum_, time1);
fprintf('Сумма с помощью sum: %f, время: %f сек.\n', sum_all, time2);

disp('//////////////////////////////////////////////////////////////////////////16');
% Создание векторов x1 и x2
x1 = linspace(-1, 1, 100);
x2 = linspace(-10, 10, 100);
% Вычисление значений sin(x1) и cos(x2)
y1 = sin(x1);
y2 = cos(x2);
% Вычисление произведения y1 и y2
y3 = y1 .* y2;
% Построение графика y3
subplot(1,3,2);
plot(y3);
xlabel('Индексы элементов');
ylabel('Произведение sin(x1) на cos(x2)');
title('График произведения sin(x1) на cos(x2)');

disp('//////////////////////////////////////////////////////////////////////////17');
% создание матрицы x1
x1 = rand(3) + 1i*rand(3);
% создание матрицы x2, хранящей модуль чисел из x1
x2 = abs(x1);
% создание матрицы x3, хранящей фазу чисел из x1
x3 = angle(x1);




% Алгоритм поэлементного нахождения отдельных элементов вектора x2
function x2 = elementwise(x1)
    x2 = zeros(1, length(x1)-1);
    for i = 1:length(x1)-1
        x2(i) = x1(i+1) - x1(i);
    end
end
% Векторизованный вариант
function x2 = vectorized(x1)
    x2 = diff(x1);
end